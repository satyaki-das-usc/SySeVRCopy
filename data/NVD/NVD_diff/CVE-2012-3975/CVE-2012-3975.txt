diff --git a/content/base/src/nsDOMParser.cpp b/content/base/src/nsDOMParser.cpp
--- a/content/base/src/nsDOMParser.cpp
+++ b/content/base/src/nsDOMParser.cpp
@@ -61,35 +61,31 @@ nsDOMParser::ParseFromString(const PRUni
 {
   NS_ENSURE_ARG(str);
   NS_ENSURE_ARG_POINTER(aResult);
 
   nsresult rv;
 
   if (!nsCRT::strcmp(contentType, "text/html")) {
     nsCOMPtr<nsIDOMDocument> domDocument;
-    rv = SetUpDocument(DocumentFlavorHTML, getter_AddRefs(domDocument));
+    nsCOMPtr<nsIChannel> parserChannel;  
+    nsCOMPtr<nsIStreamListener> listener;
+    rv = SetUpDocument(DocumentFlavorHTML,
+                       "UTF-8",
+                       contentType,
+                       getter_AddRefs(domDocument),
+                       getter_AddRefs(parserChannel),
+                       getter_AddRefs(listener));
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
     nsDependentString sourceBuffer(str);
     rv = nsContentUtils::ParseDocumentHTML(sourceBuffer, document, false);
+    document->StopDocumentLoad();
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // Keep the XULXBL state, base URL and principal setting in sync with the
-    // XML case
-
-    if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
-      document->ForceEnableXULXBL();
-    }
-
-    // Make sure to give this document the right base URI
-    document->SetBaseURI(mBaseURI);
-    // And the right principal
-    document->SetPrincipal(mPrincipal);
-
     domDocument.forget(aResult);
     return rv;
   }
 
   NS_ConvertUTF16toUTF8 data(str);
 
   // The new stream holds a reference to the buffer
   nsCOMPtr<nsIInputStream> stream;
@@ -154,65 +150,26 @@ nsDOMParser::ParseFromStream(nsIInputStr
     rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream), stream,
                                    4096);
     NS_ENSURE_SUCCESS(rv, rv);
 
     stream = bufferedStream;
   }
 
   nsCOMPtr<nsIDOMDocument> domDocument;
+  nsCOMPtr<nsIChannel> parserChannel;
+  nsCOMPtr<nsIStreamListener> listener;
   rv = SetUpDocument(svg ? DocumentFlavorSVG : DocumentFlavorLegacyGuess,
-                     getter_AddRefs(domDocument));
+                     charset,
+                     contentType,
+                     getter_AddRefs(domDocument),
+                     getter_AddRefs(parserChannel),
+                     getter_AddRefs(listener));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Create a fake channel 
-  nsCOMPtr<nsIChannel> parserChannel;
-  NS_NewInputStreamChannel(getter_AddRefs(parserChannel), mDocumentURI, nsnull,
-                           nsDependentCString(contentType), nsnull);
-  NS_ENSURE_STATE(parserChannel);
-
-  // More principal-faking here 
-  parserChannel->SetOwner(mOriginalPrincipal);
-
-  if (charset) {
-    parserChannel->SetContentCharset(nsDependentCString(charset));
-  }
-
-  // Tell the document to start loading
-  nsCOMPtr<nsIStreamListener> listener;
-
-  // Have to pass false for reset here, else the reset will remove
-  // our event listener.  Should that listener addition move to later
-  // than this call?  Then we wouldn't need to mess around with
-  // SetPrincipal, etc, probably!
-  nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
-  if (!document) return NS_ERROR_FAILURE;
-
-  // Keep the XULXBL state, base URL and principal setting in sync with the
-  // HTML case
-
-  if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
-    document->ForceEnableXULXBL();
-  }
-
-  rv = document->StartDocumentLoad(kLoadAsData, parserChannel, 
-                                   nsnull, nsnull, 
-                                   getter_AddRefs(listener),
-                                   false);
-
-  // Make sure to give this document the right base URI
-  document->SetBaseURI(mBaseURI);
-
-  // And the right principal
-  document->SetPrincipal(mPrincipal);
-
-  if (NS_FAILED(rv) || !listener) {
-    return NS_ERROR_FAILURE;
-  }
-
   // Now start pumping data to the listener
   nsresult status;
 
   rv = listener->OnStartRequest(parserChannel, nsnull);
   if (NS_FAILED(rv))
     parserChannel->Cancel(rv);
   parserChannel->GetStatus(&status);
 
@@ -450,18 +407,27 @@ nsDOMParser::Init(nsIPrincipal *aPrincip
     NS_ENSURE_TRUE(principal, NS_ERROR_UNEXPECTED);
   }
 
   return Init(principal, aDocumentURI, aBaseURI,
               scriptContext ? scriptContext->GetGlobalObject() : nsnull);
 }
 
 nsresult
-nsDOMParser::SetUpDocument(DocumentFlavor aFlavor, nsIDOMDocument** aResult)
+nsDOMParser::SetUpDocument(DocumentFlavor aFlavor,
+                           const char* aCharset,
+                           const char* aContentType,
+                           nsIDOMDocument** aResult,
+                           nsIChannel** aParserChannel,
+                           nsIStreamListener** aListener)
 {
+  *aResult = nsnull;
+  *aParserChannel = nsnull;
+  *aListener = nsnull;
+
   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
     do_QueryReferent(mScriptHandlingObject);
   nsresult rv;
   if (!mPrincipal) {
     NS_ENSURE_TRUE(!mAttemptedInit, NS_ERROR_NOT_INITIALIZED);
     AttemptedInitMarker marker(&mAttemptedInit);
 
     nsCOMPtr<nsIPrincipal> prin =
@@ -474,15 +440,52 @@ nsDOMParser::SetUpDocument(DocumentFlavo
 
   NS_ASSERTION(mPrincipal, "Must have principal by now");
   NS_ASSERTION(mDocumentURI, "Must have document URI by now");
 
   // Here we have to cheat a little bit...  Setting the base URI won't
   // work if the document has a null principal, so use
   // mOriginalPrincipal when creating the document, then reset the
   // principal.
-  return nsContentUtils::CreateDocument(EmptyString(), EmptyString(), nsnull,
-                                        mDocumentURI, mBaseURI,
-                                        mOriginalPrincipal,
-                                        scriptHandlingObject,
-                                        aFlavor,
-                                        aResult);
+  rv = nsContentUtils::CreateDocument(EmptyString(), EmptyString(), nsnull,
+                                      mDocumentURI, mBaseURI,
+                                      mOriginalPrincipal,
+                                      scriptHandlingObject,
+                                      aFlavor,
+                                      aResult);
+
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Create a fake channel 
+  NS_NewInputStreamChannel(aParserChannel, mDocumentURI, nsnull,
+                           nsDependentCString(aContentType), nsnull);
+  NS_ENSURE_STATE(*aParserChannel);
+
+  // More principal-faking here 
+  (*aParserChannel)->SetOwner(mOriginalPrincipal);
+
+  if (aCharset) {
+    (*aParserChannel)->SetContentCharset(nsDependentCString(aCharset));
+  }
+
+  nsCOMPtr<nsIDocument> document(do_QueryInterface(*aResult));
+  NS_ENSURE_STATE(document);
+
+  if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
+    document->ForceEnableXULXBL();
+  }
+
+  rv = document->StartDocumentLoad(kLoadAsData, (*aParserChannel), 
+                                   nsnull, nsnull, 
+                                   aListener,
+                                   false);
+
+  // Make sure to give this document the right base URI
+  document->SetBaseURI(mBaseURI);
+
+  // And the right principal
+  document->SetPrincipal(mPrincipal);
+
+  if (NS_FAILED(rv) || !(*aListener)) {
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
diff --git a/content/base/src/nsDOMParser.h b/content/base/src/nsDOMParser.h
--- a/content/base/src/nsDOMParser.h
+++ b/content/base/src/nsDOMParser.h
@@ -30,17 +30,22 @@ public:
   // nsIDOMParserJS
   NS_DECL_NSIDOMPARSERJS
 
   // nsIJSNativeInitializer
   NS_IMETHOD Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
                         PRUint32 argc, jsval *argv);
 
 private:
-  nsresult SetUpDocument(DocumentFlavor aFlavor, nsIDOMDocument** aResult);
+  nsresult SetUpDocument(DocumentFlavor aFlavor,
+                         const char* aCharset,
+                         const char* aContentType,
+                         nsIDOMDocument** aResult,
+                         nsIChannel** aChannel,
+                         nsIStreamListener** aListener);
 
   class AttemptedInitMarker {
   public:
     AttemptedInitMarker(bool* aAttemptedInit) :
       mAttemptedInit(aAttemptedInit)
     {}
 
     ~AttemptedInitMarker() {

