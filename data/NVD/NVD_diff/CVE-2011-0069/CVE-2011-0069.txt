diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -700,49 +700,49 @@ nsAccessControlLRUCache::GetEntry(nsIURI
   // This is a new entry, allocate and insert into the table now so that any
   // failures don't cause items to be removed from a full cache.
   entry = new CacheEntry(key);
   if (!entry) {
     NS_WARNING("Failed to allocate new cache entry!");
     return nsnull;
   }
 
-  if (!mTable.Put(key, entry)) {
-    // Failed, clean up the new entry.
-    delete entry;
-
-    NS_WARNING("Failed to add entry to the access control cache!");
-    return nsnull;
-  }
-
-  PR_INSERT_LINK(entry, &mList);
-
-  NS_ASSERTION(mTable.Count() <= ACCESS_CONTROL_CACHE_SIZE + 1,
+  NS_ASSERTION(mTable.Count() <= ACCESS_CONTROL_CACHE_SIZE,
                "Something is borked, too many entries in the cache!");
 
   // Now enforce the max count.
-  if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
+  if (mTable.Count() == ACCESS_CONTROL_CACHE_SIZE) {
     // Try to kick out all the expired entries.
     PRTime now = PR_Now();
     mTable.Enumerate(RemoveExpiredEntries, &now);
 
     // If that didn't remove anything then kick out the least recently used
     // entry.
-    if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
+    if (mTable.Count() == ACCESS_CONTROL_CACHE_SIZE) {
       CacheEntry* lruEntry = static_cast<CacheEntry*>(PR_LIST_TAIL(&mList));
       PR_REMOVE_LINK(lruEntry);
 
       // This will delete 'lruEntry'.
       mTable.Remove(lruEntry->mKey);
 
-      NS_ASSERTION(mTable.Count() == ACCESS_CONTROL_CACHE_SIZE,
+      NS_ASSERTION(mTable.Count() == ACCESS_CONTROL_CACHE_SIZE - 1,
                    "Somehow tried to remove an entry that was never added!");
     }
   }
   
+  if (!mTable.Put(key, entry)) {
+    // Failed, clean up the new entry.
+    delete entry;
+
+    NS_WARNING("Failed to add entry to the access control cache!");
+    return nsnull;
+  }
+
+  PR_INSERT_LINK(entry, &mList);
+
   return entry;
 }
 
 void
 nsAccessControlLRUCache::RemoveEntries(nsIURI* aURI, nsIPrincipal* aPrincipal)
 {
   CacheEntry* entry;
   nsCString key;
@@ -771,17 +771,17 @@ nsAccessControlLRUCache::RemoveExpiredEn
                                               nsAutoPtr<CacheEntry>& aValue,
                                               void* aUserData)
 {
   PRTime* now = static_cast<PRTime*>(aUserData);
   
   aValue->PurgeExpired(*now);
   
   if (aValue->mHeaders.IsEmpty() &&
-      aValue->mHeaders.IsEmpty()) {
+      aValue->mMethods.IsEmpty()) {
     // Expired, remove from the list as well as the hash table.
     PR_REMOVE_LINK(aValue);
     return PL_DHASH_REMOVE;
   }
   
   return PL_DHASH_NEXT;
 }
 

