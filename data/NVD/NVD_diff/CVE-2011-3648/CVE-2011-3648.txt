diff --git a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
--- a/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
+++ b/intl/uconv/ucvja/nsJapaneseToUnicode.cpp
@@ -54,16 +54,17 @@ static NS_DEFINE_CID(kCharsetConverterMa
 #else
   // HTML5 says to use Windows-31J instead of the real Shift_JIS for decoding
   #define SJIS_INDEX gCP932Index[0]
   #define JIS0208_INDEX gCP932Index[1]
 #endif
 
 #define JIS0212_INDEX gJIS0212Index
 #define SJIS_UNMAPPED	0x30fb
+#define UNICODE_REPLACEMENT_CHARACTER 0xfffd
 
 NS_IMETHODIMP nsShiftJISToUnicode::Convert(
    const char * aSrc, PRInt32 * aSrcLen,
      PRUnichar * aDest, PRInt32 * aDestLen)
 {
    static const PRUint8 sbIdx[256] =
    {
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  /* 0x00 */
@@ -164,20 +165,27 @@ NS_IMETHODIMP nsShiftJISToUnicode::Conve
             if(dest >= destEnd)
               goto error1;
           }
           break;
 
           case 1: // Index to table
           {
             PRUint8 off = sbIdx[*src];
+
+            // Error handling: in the case where the second octet is not in the
+            // valid ranges 0x40-0x7E 0x80-0xFC, unconsume the invalid octet and
+            // interpret it as the ASCII value. In the case where the second
+            // octet is in the valid range but there is no mapping for the
+            // 2-octet sequence, do not unconsume.
             if(0xFF == off) {
+               src--;
                if (mErrBehavior == kOnError_Signal)
                  goto error_invalidchar;
-               *dest++ = SJIS_UNMAPPED;
+               *dest++ = UNICODE_REPLACEMENT_CHARACTER;
             } else {
                PRUnichar ch = gJapaneseMap[mData+off];
                if(ch == 0xfffd) {
                  if (mErrBehavior == kOnError_Signal)
                    goto error_invalidchar;
                  ch = SJIS_UNMAPPED;
                }
                *dest++ = ch;
@@ -186,21 +194,24 @@ NS_IMETHODIMP nsShiftJISToUnicode::Conve
             if(dest >= destEnd)
               goto error1;
           }
           break;
 
           case 2: // EUDC
           {
             PRUint8 off = sbIdx[*src];
+
+            // Error handling as in case 1
             if(0xFF == off) {
+               src--;
                if (mErrBehavior == kOnError_Signal)
                  goto error_invalidchar;
 
-               *dest++ = SJIS_UNMAPPED;
+               *dest++ = UNICODE_REPLACEMENT_CHARACTER;
             } else {
                *dest++ = mData + off;
             }
             mState = 0;
             if(dest >= destEnd)
               goto error1;
           }
           break;
