diff -r ee5ca214e87c docshell/base/nsDSURIContentListener.cpp
--- a/docshell/base/nsDSURIContentListener.cpp	Wed Apr 10 09:20:52 2013 +0000
+++ b/docshell/base/nsDSURIContentListener.cpp	Fri Apr 19 17:33:59 2013 -0700
@@ -255,34 +255,29 @@ nsDSURIContentListener::SetParentContent
     else
     {
         mWeakParentContentListener = nullptr;
         mParentContentListener = nullptr;
     }
     return NS_OK;
 }
 
-bool nsDSURIContentListener::CheckOneFrameOptionsPolicy(nsIRequest *request,
+bool nsDSURIContentListener::CheckOneFrameOptionsPolicy(nsIHttpChannel *httpChannel,
                                                         const nsAString& policy) {
     static const char allowFrom[] = "allow-from ";
     const uint32_t allowFromLen = ArrayLength(allowFrom) - 1;
     bool isAllowFrom =
         StringHead(policy, allowFromLen).LowerCaseEqualsLiteral(allowFrom);
 
     // return early if header does not have one of the values with meaning
     if (!policy.LowerCaseEqualsLiteral("deny") &&
         !policy.LowerCaseEqualsLiteral("sameorigin") &&
         !isAllowFrom)
         return true;
 
-    nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(request);
-    if (!httpChannel) {
-        return true;
-    }
-
     nsCOMPtr<nsIURI> uri;
     httpChannel->GetURI(getter_AddRefs(uri));
 
     // XXXkhuey when does this happen?  Is returning true safe here?
     if (!mDocShell) {
         return true;
     }
 
@@ -391,17 +386,30 @@ bool nsDSURIContentListener::CheckOneFra
     return true;
 }
 
 // Check if X-Frame-Options permits this document to be loaded as a subdocument.
 // This will iterate through and check any number of X-Frame-Options policies
 // in the request (comma-separated in a header, multiple headers, etc).
 bool nsDSURIContentListener::CheckFrameOptions(nsIRequest *request)
 {
-    nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(request);
+    nsresult rv;
+    nsCOMPtr<nsIChannel> chan = do_QueryInterface(request);
+    if (!chan) {
+      return true;
+    }
+
+    nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(chan);
+    if (!httpChannel) {
+      // check if it is hiding in a multipart channel
+      rv = mDocShell->GetHttpChannel(chan, getter_AddRefs(httpChannel));
+      if (NS_FAILED(rv))
+        return false;
+    }
+
     if (!httpChannel) {
         return true;
     }
 
     nsAutoCString xfoHeaderCValue;
     httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("X-Frame-Options"),
                                    xfoHeaderCValue);
     NS_ConvertUTF8toUTF16 xfoHeaderValue(xfoHeaderCValue);
@@ -410,17 +418,17 @@ bool nsDSURIContentListener::CheckFrameO
     if (xfoHeaderValue.IsEmpty())
         return true;
 
     // iterate through all the header values (usually there's only one, but can
     // be many.  If any want to deny the load, deny the load.
     nsCharSeparatedTokenizer tokenizer(xfoHeaderValue, ',');
     while (tokenizer.hasMoreTokens()) {
         const nsSubstring& tok = tokenizer.nextToken();
-        if (!CheckOneFrameOptionsPolicy(request, tok)) {
+        if (!CheckOneFrameOptionsPolicy(httpChannel, tok)) {
             // cancel the load and display about:blank
             httpChannel->Cancel(NS_BINDING_ABORTED);
             if (mDocShell) {
                 nsCOMPtr<nsIWebNavigation> webNav(do_QueryObject(mDocShell));
                 if (webNav) {
                     webNav->LoadURI(NS_LITERAL_STRING("about:blank").get(),
                                     0, nullptr, nullptr, nullptr);
                 }
