diff --git a/intl/uconv/ucvcn/nsHZToUnicode.cpp b/intl/uconv/ucvcn/nsHZToUnicode.cpp
--- a/intl/uconv/ucvcn/nsHZToUnicode.cpp
+++ b/intl/uconv/ucvcn/nsHZToUnicode.cpp
@@ -137,20 +137,21 @@ NS_IMETHODIMP nsHZToUnicode::ConvertNoBu
             // on the second character.
             // 
             // N.B. For compatibility with other implementations, we treat '~\n'
             // as an illegal sequence even though RFC1843 permits it, and for
             // the same reason we pass through control characters including '\n'
             // and ' ' even in GB mode.
             if (srcByte > 0x20 || HZ_ENCODING_STATE == HZ_STATE_ASCII) {
               *aDest++ = UCS2_NO_MAPPING;
+              iDestlen++;
             }
             aSrc--;
             (*aSrcLength)--;
-            iDestlen++;
+            i--;
             break;
         }
       } else if (HZ_ENCODING_STATE == HZ_STATE_GB) {
         *aDest++ = (UINT8_IN_RANGE(0x21, oddByte, 0x7E) &&
                     UINT8_IN_RANGE(0x21, srcByte, 0x7E)) ?
                      mUtil.GBKCharToUnicode(oddByte|0x80, srcByte|0x80) :
                      UCS2_NO_MAPPING;
         mRunLength++;