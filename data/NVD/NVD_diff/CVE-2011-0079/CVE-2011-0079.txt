diff --git a/gfx/layers/d3d10/ReadbackManagerD3D10.cpp b/gfx/layers/d3d10/ReadbackManagerD3D10.cpp
--- a/gfx/layers/d3d10/ReadbackManagerD3D10.cpp
+++ b/gfx/layers/d3d10/ReadbackManagerD3D10.cpp
@@ -152,17 +152,17 @@ ReadbackManagerD3D10::~ReadbackManagerD3
   // to leak the thread and its synchronisation in favor of crashing or freezing
   DWORD result = ::WaitForSingleObject(mTaskThread, 5000);
   if (result != WAIT_TIMEOUT) {
     ::DeleteCriticalSection(&mTaskMutex);
     ::CloseHandle(mShutdownEvent);
     ::CloseHandle(mTaskSemaphore);
     ::CloseHandle(mTaskThread);
   } else {
-    NS_WARNING("ReadbackManager: Task thread did not shutdown in 5 seconds. Leaking.");
+    NS_RUNTIMEABORT("ReadbackManager: Task thread did not shutdown in 5 seconds.");
   }
 }
 
 void
 ReadbackManagerD3D10::PostTask(ID3D10Texture2D *aTexture, void *aUpdate, const gfxPoint &aOrigin)
 {
   ReadbackTask *task = new ReadbackTask;
   task->mReadbackTexture = aTexture;
@@ -222,16 +222,19 @@ ReadbackManagerD3D10::ProcessTasks()
   
   while (true) {
     DWORD result = ::WaitForMultipleObjects(2, handles, FALSE, INFINITE);
     if (result != WAIT_OBJECT_0) {
       return;
     }
 
     ::EnterCriticalSection(&mTaskMutex);
+    if (mPendingReadbackTasks.Length() == 0) {
+      NS_RUNTIMEABORT("Trying to read from an empty array, bad bad bad");
+    }
     ReadbackTask *nextReadbackTask = mPendingReadbackTasks[0].forget();
     mPendingReadbackTasks.RemoveElementAt(0);
     ::LeaveCriticalSection(&mTaskMutex);
 
     // We want to block here until the texture contents are available, the
     // easiest thing is to simply map and unmap.
     D3D10_MAPPED_TEXTURE2D mappedTex;
     nextReadbackTask->mReadbackTexture->Map(0, D3D10_MAP_READ, 0, &mappedTex);
