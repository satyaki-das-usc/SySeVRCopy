diff --git a/js/xpconnect/src/XPCComponents.cpp b/js/xpconnect/src/XPCComponents.cpp
--- a/js/xpconnect/src/XPCComponents.cpp
+++ b/js/xpconnect/src/XPCComponents.cpp
@@ -3765,16 +3765,61 @@ nsXPCComponents_Utils::EvalInSandbox(const nsAString& source,
             frame->GetLineNumber(&lineNo);
         }
     }
 
     return xpc_EvalInSandbox(cx, sandbox, source, filename.get(), lineNo,
                              jsVersion, false, retval);
 }
 
+struct NS_STACK_CLASS AutoSecurityJunkPusher {
+
+    JSContext                *mCx;
+    nsIPrincipal             *mPrincipal;
+    XPCJSContextStack        *mStack;
+    nsIScriptSecurityManager *mSSM;
+    bool                      mPushed;
+
+    AutoSecurityJunkPusher(JSContext *cx, nsIPrincipal *principal)
+     : mCx(cx)
+     , mPrincipal(principal)
+     , mStack(XPCPerThreadData::GetData(cx)->GetJSContextStack())
+     , mSSM(XPCWrapper::GetSecurityManager())
+     , mPushed(false) { }
+
+    bool Push() {
+
+        // First, push the js context.
+        if (!mStack->Push(mCx)) {
+            JS_ReportError(mCx, "Unable to initialize XPConnect with the sandbox context");
+            return false;
+        }
+
+        // Then, push the principal.
+        nsresult rv = mSSM->PushContextPrincipal(mCx, nsnull, mPrincipal);
+        if (NS_FAILED(rv))
+            return false;
+
+        mPushed = true;
+        return true;
+    }
+
+    void Pop() {
+        MOZ_ASSERT(mPushed);
+        mSSM->PopContextPrincipal(mCx);
+        mStack->Pop();
+    }
+
+    ~AutoSecurityJunkPusher() {
+        if (mPushed)
+            Pop();
+    }
+
+};
+
 nsresult
 xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
                   const char *filename, PRInt32 lineNo,
                   JSVersion jsVersion, bool returnStringOnly, jsval *rval)
 {
     JS_AbortIfWrongThread(JS_GetRuntime(cx));
 
 #ifdef DEBUG
@@ -3831,35 +3876,27 @@ xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
     if (!sandcx || !sandcx->GetJSContext()) {
         JS_ReportError(cx, "Can't prepare context for evalInSandbox");
         return NS_ERROR_OUT_OF_MEMORY;
     }
 
     if (jsVersion != JSVERSION_DEFAULT)
         JS_SetVersion(sandcx->GetJSContext(), jsVersion);
 
-    XPCPerThreadData *data = XPCPerThreadData::GetData(cx);
-    XPCJSContextStack *stack = nsnull;
-    if (data && (stack = data->GetJSContextStack())) {
-        if (!stack->Push(sandcx->GetJSContext())) {
-            JS_ReportError(cx,
-                           "Unable to initialize XPConnect with the sandbox context");
-            return NS_ERROR_FAILURE;
-        }
-    }
+    AutoSecurityJunkPusher pusher(sandcx->GetJSContext(), prin);
+    if (!pusher.Push())
+        return NS_ERROR_FAILURE;
 
     nsresult rv = NS_OK;
 
     {
         JSAutoRequest req(sandcx->GetJSContext());
         JSAutoEnterCompartment ac;
 
         if (!ac.enter(sandcx->GetJSContext(), sandbox)) {
-            if (stack)
-                unused << stack->Pop();
             return NS_ERROR_FAILURE;
         }
 
         jsval v;
         JSString *str = nsnull;
         JSBool ok =
             JS_EvaluateUCScriptForPrincipals(sandcx->GetJSContext(), sandbox,
                                              nsJSPrincipals::get(prin),
@@ -3925,19 +3962,16 @@ xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
             }
 
             if (NS_SUCCEEDED(rv)) {
                 *rval = v;
             }
         }
     }
 
-    if (stack)
-        unused << stack->Pop();
-
     return rv;
 }
 
 /* JSObject import (in AUTF8String registryLocation,
  *                  [optional] in JSObject targetObj);
  */
 NS_IMETHODIMP
 nsXPCComponents_Utils::Import(const nsACString& registryLocation,
