diff --git a/netwerk/protocol/http/nsHttpHeaderArray.cpp b/netwerk/protocol/http/nsHttpHeaderArray.cpp
--- a/netwerk/protocol/http/nsHttpHeaderArray.cpp
+++ b/netwerk/protocol/http/nsHttpHeaderArray.cpp
@@ -42,27 +42,27 @@
 
 //-----------------------------------------------------------------------------
 // nsHttpHeaderArray <public>
 //-----------------------------------------------------------------------------
 
 nsresult
 nsHttpHeaderArray::SetHeader(nsHttpAtom header,
                              const nsACString &value,
-                             PRBool merge)
+                             PRBool merge, PRBool replace)
 {
     nsEntry *entry = nsnull;
     PRInt32 index;
 
     index = LookupEntry(header, &entry);
 
     // If an empty value is passed in, then delete the header entry...
     // unless we are merging, in which case this function becomes a NOP.
     if (value.IsEmpty()) {
-        if (!merge && entry)
+        if (!merge && entry && replace)
             mHeaders.RemoveElementAt(index);
         return NS_OK;
     }
 
     // Create a new entry, or...
     if (!entry) {
         entry = mHeaders.AppendElement(); //new nsEntry(header, value);
         if (!entry)
@@ -70,28 +70,31 @@ nsHttpHeaderArray::SetHeader(nsHttpAtom 
         entry->header = header;
         entry->value = value;
     }
     // Append the new value to the existing value iff...
     else if (merge && CanAppendToHeader(header)) {
         if (header == nsHttp::Set_Cookie ||
             header == nsHttp::WWW_Authenticate ||
             header == nsHttp::Proxy_Authenticate)
+        {
             // Special case these headers and use a newline delimiter to
             // delimit the values from one another as commas may appear
             // in the values of these headers contrary to what the spec says.
             entry->value.Append('\n');
-        else
+        } else {
             // Delimit each value from the others using a comma (per HTTP spec)
             entry->value.AppendLiteral(", ");
+        }
         entry->value.Append(value);
-    }
-    // Replace the existing string with the new value
-    else
+    } else if (replace) {
+        // replace old value
         entry->value = value;
+    } // else don't replace existing value: just fall down to return NS_OK
+
     return NS_OK;
 }
 
 void
 nsHttpHeaderArray::ClearHeader(nsHttpAtom header)
 {
     mHeaders.RemoveElement(header, nsEntry::MatchHeader());
 }
@@ -178,17 +181,17 @@ nsHttpHeaderArray::ParseHeaderLine(const
                // consisted of LWS, then p2 would have pointed at |p-1|, so
                // the prefix increment is always valid.
 
     // assign return values
     if (hdr) *hdr = atom;
     if (val) *val = p;
 
     // assign response header
-    SetHeader(atom, nsDependentCString(p, p2 - p), PR_TRUE);
+    SetHeader(atom, nsDependentCString(p, p2 - p), PR_TRUE, PR_FALSE);
 }
 
 void
 nsHttpHeaderArray::Flatten(nsACString &buf, PRBool pruneProxyHeaders)
 {
     PRUint32 i, count = mHeaders.Length();
     for (i = 0; i < count; ++i) {
         const nsEntry &entry = mHeaders[i];
diff --git a/netwerk/protocol/http/nsHttpHeaderArray.h b/netwerk/protocol/http/nsHttpHeaderArray.h
--- a/netwerk/protocol/http/nsHttpHeaderArray.h
+++ b/netwerk/protocol/http/nsHttpHeaderArray.h
@@ -49,17 +49,23 @@
 class nsHttpHeaderArray
 {
 public:
     nsHttpHeaderArray() {}
    ~nsHttpHeaderArray() { Clear(); }
 
     const char *PeekHeader(nsHttpAtom header);
 
-    nsresult SetHeader(nsHttpAtom header, const nsACString &value, PRBool merge = PR_FALSE);
+    // If 'merge', duplicate headers will have values merged.
+    // If merging not possible/requested, value will replace previous value
+    // if 'replace' set, else previous value will remain.
+    nsresult SetHeader(nsHttpAtom header, const nsACString &value,
+                       PRBool merge = PR_FALSE,
+                       PRBool replace = PR_TRUE);
+
     nsresult GetHeader(nsHttpAtom header, nsACString &value);
     void     ClearHeader(nsHttpAtom h);
 
     // Find the location of the given header value, or null if none exists.
     const char *FindHeaderValue(nsHttpAtom header, const char *value) {
         return nsHttp::FindToken(PeekHeader(header), value,
                                  HTTP_HEADER_VALUE_SEPS);
     }
